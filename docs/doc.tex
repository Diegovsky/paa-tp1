\documentclass[12pt]{article}

\title{Titulo}
\date{Maio de 2023}
\author{Diego Augusto}

% Syntax highlighting:
% \usepackage{minted}
% Imagens:
\usepackage{graphicx}
\graphicspath{ {./imagens/} }
% \usepackage[margin=3cm]{geometry}
\usepackage[
backend=biber,
style=ieetr,
]{biblatex} %Imports biblatex package
\addbibresource{cit.bib}

\newcommand\image[1]{\noindent\includegraphics[width=\textwidth]{#1}}

\usepackage{indentfirst}
\setlength{\parindent}{1.5cm}

\begin{document}
    \pagenumbering{arabic}

    \maketitle
    \newpage
    \section{Introdução}
    O problema proposto para solucionar reside em um contexto de reinos
    encantados, onde deseja-se encontrar os $K$ caminhos mínimos saindo do reino Mysthollow até o reino de Luminae. Entre esses
    reinos existem $N$ cidades, e os caminhos entre as cidades contêm desafios. Este
    problema é bem conhecido na literatura e pode ser representado por um grafo.
    Portanto, aplicaremos uma técnica para encontrar o caminho mínimo (ou custo
    mínimo) em um grafo ponderado, onde os vértices são as cidades, tendo a
    cidade inicial como o reino de Mysthollow e a cidade final como o reino de
    Luminae. As arestas representam as ligações entre as cidades, e os desafios
    entre as cidades serão representados pelos pesos. Assim, resolver este
    problema significa determinar o caminho entre dois vértices com o custo
    mínimo, ou seja, com o menor tempo de viagem.

    Os dados para a construção do grafo são fornecidos pelo usuário através de um
    arquivo de entrada, e a solução do problema será apresentada em um arquivo de
    saída. O principal foco deste trabalho é o desenvolvimento e análise de
    algoritmos que solucionam o problema, levando em consideração a eficiência deles
    nos diversos contextos em que o problema pode estar inserido. Portanto, durante
    a execução do trabalho, foram analisados mais de um algoritmo para encontrar
    caminhos mínimos, pois a eficiência de alguns algoritmos é comprometida em
    certos contextos possíveis.

    Diante disso, é necessário desenvolver um programa que, além de encontrar a
    solução, preocupa-se com a otimização e facilite a manutenção por meio de boas
    práticas de programação e uma documentação adequada, como será demonstrado nas
    próximas seções.
    \section{Desenvolvimento do Projeto}

    \image{fluxo}

    \subsection{Detalhes de implementação}
    Para representar o grafo, utilizamos a representação de lista de adjacência.
    Uma lista de adjacência consiste em uma lista de tamanho $|V|$, onde cada
    elemento guarda uma lista encadeada contendo as arestas do nó naquele
    índice. Ou seja: as arestas que saem do nó $v$ ficam guardadas no índice
    $v-1$ da lista de adjacência.

    Fizemos essa escolha pois é uma representação relativamente simples de se
    implementar, além de performar bem em grafos esparsos e razoavelmente em
    grafos densos se comparado à uma matriz de adjacência \cite{codeforce}.

    \textbf{Imagem de uma lista de adjacencia}
    \\

    Para desenvolver a solução, optamos pelo algoritmo de Eppstein. Fizemos essa
    escolha pensando em várias características do problema, como a quantidade de
    nós, arestas e o valor de $K$. Isso se deve ao fato de que os valores de $K$
    não excedem 10, tornando o algoritmo bem rápido. O motivo será explicado nas
    próximas seções.

    \subsection{Lista Dinâmica}
    Para implementar várias estruturas de dados, criamos uma lista paramétrica
    homogênea, que funciona para vários tipos de elementos, todos do mesmo tipo,
    como as listas de linguagens de programação com suporte para tipos
    paramétricos (Rust, Java, C++, etc). Sua implementação encontra-se nos
    arquivos \texttt{list.h} e \texttt{list.c}.

    A nossa lista consiste em um ponteiro para um arranjo alocado dinamicamente,
    o tamanho do elemento, o comprimento da lista e a capacidade de alocação de
    memória. Para tornar as inserções eficientes, reservamos mais espaço do que
    elementos contidos na lista, assim, quando temos espaço sobrando, apenas
    precisamos incrementar o contador de elementos. Isso faz com que as
    inserções não tenham um impacto significativo na execução do programa, pois
    as realocações são esporádicas.

    \image{lista}

    \newpage

    \printbibliography[title={Fontes}]


    \section{Análises de complexidades}
    O algoritmo de Eppstein utiliza como base o algoritmo de Dijkstra, então antes de analisarmos o Eppstein, vamos analisar o Dijkstra.
    O Dijkstra, quando implementado com listas de adjacência e heap binária, tem complexidade de $O(n\log n + m)$, sendo $n$ os vértices e $m$ as arestas. Como o algoritmo inicializa as distâncias de cada vértice e cria uma fila de prioridade com o custo de $O(n)$, a cada passo do algoritmo, ele extrai o vértice com custo mínimo e aplica a técnica de relaxamento, que tem custo $O(\log n)$, e todas as arestas são visitadas com custo $O(m)$. Portanto, chegamos na complexidade de $O(n\log n + m)$.
    
    Como dito nas seções anteriores, o Eppstein assume que $n \leq m$, então a ordem de complexidade que domina assintoticamente é em função de $m$, por isso que no Eppstein analisamos em função de $m$, não mais de $n$ como no Dijkstra. Além disso, o Eppstein permite que um vértice apareça várias vezes na heap, pois estamos analisando todas as arestas que incidem naquele vértice. Por isso, o pior caso aumenta para $m$, pois isso representa outros caminhos, no caso de arestas compartilhadas.
    
    O algoritmo analisa cada aresta que sai do vértice atual e realiza uma inserção na heap cujo o custo no pior caso é $O(\log m)$. Como esse processo é feito no máximo $m$ vezes, o custo total para inserir todas as arestas na heap é $O(m \log m)$. Porém, como queremos os $k$ menores caminhos, essa lógica será executada $k$ vezes, então conclui-se que a complexidade do algoritmo de Eppstein é $O(km \log (km))$.

    \section{Resultados e Análises}


    \printbibliography[title={Whole bibliography}]
\end{document}
